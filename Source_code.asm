ORG 00H

 ANS_F BIT 79H
 ADDED_VALUE EQU 74H ; ADDED VALUE FROM FLOAT
 MULT_INTERMIDEATE EQU 70H ; INCASE THE VALUE EXCEDED 255
 FIRST_SECOND_FLOAT BIT 16H ; TO DETERMINE WHICH FLOAT WILL BE STORED
 COMP_FLOAT EQU 73H ; COMPIEND FLOAT VALUE 'REAL VALUE'
 FIRST_FLOAT EQU 71H ; SOTORE FIRST FLOAT
 SECOND_FLOAT EQU 72H ; STORE SECOND FLOAT
 DIIV BIT 42H ; DIV EXCEPTION
 SUUB BIT 13H ; SUB EXCEPTION
 REAL BIT 41H ; REAL VALUE EXCEPTION
 CONT BIT 40H ; BUILD UP OPERATION EXCEPTION
 FIRST_RESULT EQU 50H ; BUILD UP OPERATION FIRST RESULT
 SECOND_RESULT EQU 51H ; BUILD UP OPERATION SECOND RESULT
 CLEAR BIT 15H ; DAT ROUTINE CLEAR ENABLE BIT
 ERROR_FLAG EQU 2AH ; ERROR BYTE
 FIRST_DIGIT BIT 50H ; FIRST DIGIT ERROR FLAG
 SECOND_DIGIT BIT 51H ; SECOND DIGIT ERROR FLAG
 THIRD_DIGIT BIT 54H ; THIRD DIGIT ERROR FLAG
 FIRST_SIGN BIT 52H ; FIRST SIGN ERROR FLAG
 SECOND_SIGN BIT 53H ; SECOND SIGN ERROR FLAG
 NEW_OPERATION BIT 65H ; NEW OPERATION INDICATION FLAG
 OPERATION_SIGN BIT 60H ; SIGN OR OPERATION EXCECUTION FLAG
 DATA_OPERATION BIT 20H ; DATA OR OPERATION AS INPUT FLAG
 FIRST_SECOND_DIGIT BIT 10H ; FIRST OR SECOND DIGIT FLAG
 THIRD_F_S_DIGIT BIT 11H ; THIRD OR FIRST OR SECOND FLAG
 FIRST_SECOND_SIGN BIT 12H ; FIRST OR SECOND SIGN FLAG

 ;----------------INTIAL VALUES-----------------------------

 CLR FIRST_SECOND_FLOAT ; IF =0, FIRST FLOAT IS ON THE WAY
 ; IF =1, FIRST FLOAT ARRIVED, SECOND FLOAT IS ON THE WAY
 MOV MULT_INTERMIDEATE,#0
 CLR FIRST_SECOND_DIGIT ; IF =0, FIRST DIGIT IS ON THE WAY
 ; IF =1, SECOND DIGIT IS ON THE WAY, FIRST IS ALREADY HERE
 CLR CONT ; TO ELMINATE ANY BUILD UP OPERATION
 CLR REAL ; TO AVOID MASKING THE FIRST DIGIT INCASE OF A REAL VLAUE
 7
 CLR DIIV ; IF =0, NO FLOATING VALUE IN RESULT
 ; IF =1, THERE IS A FLOATING VALUE
 SETB CLEAR ; IF =0, ALLOW DAT TO CLEAR
 ; IF =1, DAT CAN'T DELETE

 CLR FIRST_SECOND_SIGN ; 1-IF =0 :FIRST SIGN IS ON THE WAY
 ; 2-IF =1 :SECOND SIGN IS ON THE WAY, FIRST SIGN IS ALREADY HERE
 ; 3-IF =0 : SECOND SIGN IS HERE
CLR NEW_OPERATION ; TO REINTIALIZE & RESET FLAGS
 CLR OPERATION_SIGN ; IF =0, SIGN ROUTINE WILL GET A SIGN
 ; IF =1, SIGN RPUTINE WILL GET A '='
 MOV R0,#60H ; DATA STORAGE ADDRESS
 CLR DATA_OPERATION ; TO MAKE DAT THE FIRST ROUTINE TO RECIEVE AN INPUT
 MOV ERROR_FLAG,#0 ; TO RESET THE ERROR FLAG
 ACALL INTIALIZER
; LCD INTIALIZING
;-------------------------------KEY PAD-----------------------------------
 MOV P3,#0FFH
 NEXT5:
 MOV P2,#0
 NEXT:
 MOV A,P3
 ANL A,#00001111B
 CJNE A,#00001111B,NEXT
 NEXT2:
 MOV A,P3
 ANL A,#00001111B
 CJNE A,#00001111B,OVER
 SJMP NEXT2
 OVER:
 JNB NEW_OPERATION,SAME_OPERATION ;IF =0, KEEP THE FLOW
 ;IF =1, REINTIALIZE
 ACALL INTIALIZER
 SETB CLEAR
 CLR NEW_OPERATION ; TO AVOID ENTERING HERE UNLESS AN OPERATION IS FINISHED
 SAME_OPERATION: ACALL DELAY
 MOV A,P3
 ANL A,#00001111B
 CJNE A,#00001111B,OVER2
 8
 SJMP NEXT2
 OVER2:
 MOV P2,#11111110B
 MOV A,P3
 ANL A,#00001111B
 CJNE A,#00001111B,ROW0
 MOV P2,#11111101B
 MOV A,P3
 ANL A,#00001111B
 CJNE A,#00001111B,ROW1
 MOV P2,#11111011B
 MOV A,P3
 ANL A,#00001111B
 CJNE A,#00001111B,ROW2
 MOV P2,#11110111B
 MOV A,P3
 ANL A,#00001111B
 CJNE A,#00001111B,ROW3
 SJMP NEXT2
 ROW0: MOV DPTR,#KEY0
 SJMP FIND
 ROW1: MOV DPTR,#KEY1
 SJMP FIND
 ROW2: MOV DPTR,#KEY2
 SJMP FIND
 ROW3: MOV DPTR,#KEY3
 SJMP FIND
 FIND:
 RRC A
 JNC MATCH
 INC DPTR
 SJMP FIND
 MATCH: CLR A
 MOVC A,@A+DPTR ; A HAS ASCII REPRSENTAION OF THE INPUT
 ;--------------------------------------------------------------------------------------
 ; WE HAVE AN INPUT ALREADY
 JB DATA_OPERATION,OP ; IF =0, DAT WILL RECIEVE THE VALUE
 SETB DATA_OPERATION ; IF =1, SIGN WILL RECIEVE THE VALUE
 ;ACCURATE FLOW: DIGIT --> SIGN --> DIGIT --> '='
 ;DIGIT --> SIGN --> DIGIT --> SIGN --> DIGIT --> '='
 9
 SJMP DT
 OP:
 ACALL SIGN
 LJMP NEXT5
 DT:
 ACALL DAT
 SETB DATA_OPERATION ; TO IDICATE THAT THE NEXT INPUT IS A SIGN
 JNB CONT,S_K_P ; INCASE OF A BUILD UP OPERATION
 CLR DATA_OPERATION ; INCASE OF 'ANS' THE NEXT INPUT IS DATA
 SETB OPERATION_SIGN ; TO INDICATE THAT THE NEXT INPUT TO SIGN ROUTINE IS EITHER
 CLR ANS_F ; A SECOND SIGN OR '='
 SETB FIRST_SECOND_DIGIT ; TO INDICATE THAT THE NEXT DATA WILL BE THE SECOND ONE
 CLR CONT ; TO AVOID ENTERING HERE WHILE SECOND DATA ENTERY
 S_K_P:
 LJMP NEXT5
 ;---------------------------------------------------
 DAT:
 CJNE A,#'C',NERASE ; IF (A) NOT = C --> JUMP NERASE (NOT ERASE)
 JB CLEAR,SKKP ; IF CLEAR =1 --> DAT CANN'T DELETE --> NOTHING IS WRITTEN YET
 ; CHECKS IF THIS IS THE FIRST INPUT, IF TRUE REINTIALIZE
 MOV A,#10H ; IF CLEAR =0 --> DAT CAN DELETE
 ACALL COM
 MOV A,#' ' ;OVER WRITE ON THE DATA WITH EMPTY SPACE
 ACALL DATAA
 MOV A,#10H ;SHL ONE FOR CORSER TO BE READY TO WRITE THE CORRECT DATA
 ACALL COM

 JNB FIRST_SECOND_SIGN,SECOND_ERROR_ERASE; ; IF =0 ,SECOND SIGN HAS ARRIVED
 ; IF =1 FIRST SIGN ARRIVED
 ; SECOND SIGN IS YET TO COME
 SETB DATA_OPERATION ; NEXT INPUT IS STILL OPERATION
 CLR OPERATION_SIGN ; MAKE 'FIRST' TAKE THE SIGN AGAIN
 CLR FIRST_SIGN ; REMOVE ERROR FLAG DESIGNATED FOR FIRST SIGN
 LJMP NEXT5
 SECOND_ERROR_ERASE:
 SETB DATA_OPERATION ; NEXT INPUT IS STILL OPERATION
 SETB OPERATION_SIGN ; MAKE 'NERASE' TAKE THE SIGN AGAIN
 CLR SECOND_SIGN ; REMOVE ERROR FLAG
 LJMP NEXT5
 SKKP: ; CLEAR=1 THEN DELETE ALL AND START AGAIN
 10
 SETB NEW_OPERATION ; READY FOR NEW OPERATION
 CLR DATA_OPERATION ; NEXT INPUT IS DATA
 CLR CONT ; IF =1 AN OPERATION HAS ALREADY HAPPEND
 ; IF= 0 THIS IS THE FIRST OPERATION EVER
 LJMP NEXT5
 NERASE: ;NOT ERASE
 JNB CONT,START_OVER ; ANS FEATURE, CHECKS IF IT'S A BUILD UP OPEARATION
 CJNE A,#30H,ANS
 SJMP T11
 ANS: JC SIG ; IF C=1 --> (A) < 30H(SIGNS) , C=0 --> (A) >= 30H - '=' OR NUMBER
 CJNE A,#'=',EQQ ; '=' HAS ASCII VALUE LARGER THAN 30H
 JB CLEAR,SKKP
 EQQ:
 SJMP T11
 SIG: ; SURE THAT INPUT IS SIGN AFTER ANS
 ACALL ANS_FEATURE
 SJMP T12
 START_OVER:
 CJNE A,#'=',TRU ; CHECK IF '=' IS PRESSED BEFORE THE TOTAL OPERATION IS ENTERED
 JB CLEAR,SKKP ; REINTIALIZE IF IT'S A NEW OPERAION OR A LCD IS EMPTY
 ACALL ERR
 ACALL RESET_FLAGS
 LJMP NEXT5
 TRU: ; DATA ISN'T 'C' , '='
 CJNE A,#30H,T00
 T11: ;SURE THAT INPUT NUMS:-0:9-
 ACALL DATAA
 T12:MOV @R0,A ;60H --> STORE THE 1ST DIGIT
 INC R0 ;61 35 ;61H -->READY FOR THE
 JB FIRST_SECOND_DIGIT,SECOND
 SETB FIRST_SECOND_DIGIT ; SECOND DIGIT IS ON THE WAY
 JB ANS_F,SKIPPPP
 CLR CONT
 SKIPPPP:
 RET
 SECOND: CLR FIRST_SECOND_DIGIT ; FIRST DIGIT IS ON THE WAY
 JB ANS_F,SKIPP000ZZ
 CLR CONT
 SKIPP000ZZ:
 RET
 11
 T00: JNC T11 ;C=0 --> A >= 30H
 JNB FIRST_SECOND_DIGIT,FIRST_D
 CLR FIRST_SECOND_DIGIT
 SETB SECOND_DIGIT ;IF 1 --> ERROR
 SJMP SHW
 FIRST_D:SETB FIRST_DIGIT ; FIRST DIGIT IS WRONG
 SETB FIRST_SECOND_DIGIT ; TO INDICATE THAT THE NEXT VALUE IS THE SECOND DIGIT
 SHW:ACALL DATAA
 INC R0
 RET
 SIGN:
 CLR CLEAR ; TO TELL DAT SUB ROUTINE TO CLEAR A DIGIT IF IT RECIEVED 'C'
 CLR DATA_OPERATION ; TO INDICATE THAT THE NEXT INPUT IS DATA
 CJNE A,#'C',NERASE1
 JNB FIRST_SECOND_DIGIT,N_ALLOW_CLEAR ; INCASE IT WAS ZER0,MEANING THERE IS TWO
DATA & ONE SIGN ON THE LCD FOR
 ; DAT ROUTINE TO ERASE
 SETB CLEAR ; PREVENT DAT FROM DELETING
 N_ALLOW_CLEAR:
 MOV A,#10H
 ACALL COM
 MOV A,#' '
 ACALL DATAA
 MOV A,#10H
 ACALL COM
 JB FIRST_SECOND_DIGIT,FIRST_D_C ; TO KNOW WICH ERROR FLAG TO CLEAR
 SETB FIRST_SECOND_DIGIT ; INDICATION THAT THE SECOND DATA WILL BE RE ENTERD
 CLR SECOND_DIGIT ; CLR ERROR FLAG FOR THE ERASED VALUE
 SJMP SHW0
 FIRST_D_C:
 CLR FIRST_DIGIT ; CLR ERROR FLAG FOR THE ERASED VALUE
 CLR FIRST_SECOND_DIGIT ; INDICATION THAT THE FIRST DATA WILL BE RE ENTERD
 SHW0:
 DEC R0 ; TO RE ENTER IN THE SAME PLACE
 LJMP NEXT5
 NERASE1:
 JNB OPERATION_SIGN,FIRST0
 SJMP N_FLOW ; CHECK IF THIS IS THE FIRST SIGN OR ( '=' & SECOND SIGN )
 FIRST0: LJMP FIRST ; IF =0, FIRST SIGN
 N_FLOW: ; IF =1, '=' OR SECOND SIGN
 12
 CJNE A,#'=',SECOND_SIGN_INPUT
 ACALL DATAA
 MOV A,ERROR_FLAG ; CHECK IF ANY ENTERD VALUE IS WRONG
 JZ SUCESSFUL
 MOV ERROR_FLAG,#0
 ERRR:
 ACALL ERR
 ACALL RESET_FLAGS
 LJMP NEXT5
 SECOND_SIGN_INPUT:
 CLR FIRST_SECOND_SIGN ; TO INDICATE THAT THE SECOND SIGN HAS ARRIVED
 CJNE A,#30H,SECOND_SIGN_ERROR
 SIGN_WRONG:SETB SECOND_SIGN ; SECOND SIGN IS WRONG
 ACALL DATAA
 CLR DATA_OPERATION ; INDICATE THAT THE NEXT INPUT SHOULD BE DATA
 ;SETB THIRD_F_S_DIGIT ; NEXT INPUT IN LINE IS DATA
 LJMP NEXT5
 SECOND_SIGN_ERROR:
 JNC SIGN_WRONG
 MOV 41H,A ; SECOND SIGN IS TRUE
 ACALL DATAA
 CLR DATA_OPERATION ; INDICATE THAT THE NEXT INPUT SHOULD BE DATA
 ;SETB THIRD_F_S_DIGIT ; NEXT INPUT IN LINE IS DATA
 LJMP NEXT5
 ;--------------------------------------------------
 SUCESSFUL:
 MOV A,42H ; FIRST SIGN
 CJNE A,#'*',NEX1
 ACALL MULT
 SETB NEW_OPERATION ; TO REINTIALIZE THE LCD
 CLR OPERATION_SIGN ; TO TELL THE SIGN ROUTINE THAT THE FIRST INPUT IS A SIGN NOT A
'='
 SETB CONT ; TO INDICATE THAT THERE MIGHT BE A BUILD UP
 MOV R0,#60H ; START AGAIN AT 60H
 CLR REAL ; TO ALLOW THE MASK TO BE TAKEN IN CASE OF NORMAL FLOW (ASCII
VALUE)
 CLR FIRST_SECOND_SIGN ; TO START AT THE FIRST SIGN AGAIN
 LJMP NEXT5
 ;-----------------------------------------------------
 NEX1: CJNE A,#'+',NEX2
 13
 ACALL ADDD
 SETB NEW_OPERATION ; TO REINTIALIZE THE LCD
 CLR OPERATION_SIGN ; TO TELL THE SIGN ROUTINE THAT THE FIRST INPUT IS A SIGN NOT A '='
 MOV R0,#60H ; START AGAIN AT 60H
 SETB CONT ; INDICATE THAT THE NEXT OPERATION MIGHT BE A BUILD UP
 CLR REAL ; TO ALLOW THE MASK TO BE TAKEN IN CASE OF NORMAL FLOW (ASCII VALUE)
 CLR FIRST_SECOND_SIGN ; TO START AT THE FIRST SIGN AGAIN
 LJMP NEXT5
 ;----------------------------------------------------------
 NEX2: CJNE A,#'-',NEX3
 ACALL SUB
 SETB NEW_OPERATION
 CLR OPERATION_SIGN
 MOV R0,#60H
 SETB CONT
 CLR REAL
 CLR FIRST_SECOND_SIGN ; TO START AT THE FIRST SIGN AGAIN
 LJMP NEXT5
 ;---------------------------------------------------
 NEX3: CJNE A,#'/',NEX4
 ACALL DIVV
 SETB NEW_OPERATION
 CLR OPERATION_SIGN
 MOV R0,#60H
 SETB CONT
 CLR REAL
 CLR FIRST_SECOND_SIGN ; TO START AT THE FIRST SIGN AGAIN
 LJMP NEXT5
 ;-------------------------------------------------------
 NEX4: ; INCASE AN ERROR OCCURD , DIDN'T FIND A MATCH
 ACALL ERR
 SETB NEW_OPERATION
 CLR OPERATION_SIGN
 MOV R0,#60H
 SETB CONT
 CLR REAL
 CLR FIRST_SECOND_SIGN ; TO START AT THE FIRST SIGN AGAIN
 LJMP NEXT5
 ;-----------------------------------------------------
 FIRST:
 14
 CLR DATA_OPERATION ; TO INDICATE THAT THE NEXT INPUT IS DATA
 SETB OPERATION_SIGN ; TO INDICATE THAT THE NEXT SING ROUTINE INPUT MAYBE
 ; ('=' & SECOND SIGN)
 CJNE A,#'=',TR ; FEATURE*
 MOV A,#0CFH ; MOVE CURSER TO THE MOST RIGHT IN NEXT LINE
 ACALL COM
 JB FIRST_DIGIT,ERRR0
 SJMP N_FLOW0
 ERRR0:
 LJMP ERRR
 N_FLOW0: ; CHECK IF THE FIRST DIGIT IS ACCURATE IN THE FIRST PLACE
 MOV A,60H ; THE FIRST DATA VALUE
 ACALL DATAA
 ACALL RESET_FLAGS
 LJMP NEXT5
 TR:
 SETB FIRST_SECOND_SIGN ; INDICATES THAT THE FIRST SIGN HAS ARRIVED
 ; THE SECOND SIGN IS ON THE WAY
 CJNE A,#30H,Q
 Q1:
 SETB FIRST_SIGN ; RAISE ERROR FLAG, FIRST SIGN IS WRONG
 ACALL DATAA ; DISPLAY ERROR NUM
 LJMP NEXT5
 Q: JNC Q1
 MOV 42H,A ; STORE THE SIGN IN MEM
 ACALL DATAA
 RET
 ;---------------------------------------------------------------
 MULT:
 JNB DIIV,NO_FLOAT0 ; CHECK IF THE PREVIOUS RESULT HAS A FLOATING VALUE
 ACALL MUL_FLOAT ; APPLY MULT TO FLOAT SEPREATLY
 CLR DIIV
 NO_FLOAT0:
 MOV A,60H ;ASCII OR REAL VALUE, INCASE OF A BUILD UP
 MOV B,61H
 JB REAL,REL ; IF REAL , SKIP MASK
 ANL A,#0FH
 REL:
 ANL B,#0FH
 15
 MUL AB ; A= LOWER , B= HIGHER
 PUSH ACC ; SAVE A INTO STACK
 MOV A,B
 JZ LESS ; CHECK IF THE RESULT IS LARGER THAN #FFH
 POP ACC
 MOV R4,#0 ; COUNTER
 REPEAT:
 CLR C
 SUBB A,#64H ; 64H --> 100D , MAXIMUM SINGLE TIME O/P IS LESS THAN 1000
 ; LOWER SUBTRACTED FROM LOWER
 MOV R5,A
 MOV A,B
 SUBB A,#00H ; HIGHER SUBTRACTED FROM HIGHER
 MOV B,A
 MOV A,R5
 JC EXIT ; IF =1, THE NUMBER IS FINISHED
 INC R4 ; RESULT
 SJMP REPEAT
 EXIT:
 ADD A,#64H ; DECIMAL 100
 MOV B,A ; REMINDER --> 29
 MOV A,R4 ; RESULT --> 7
 MOV MULT_INTERMIDEATE,A ; HIGHEST ORDER VALUE
 MOV A,B
 SJMP LESS1 ; SURE THAT (A) HAS A LESS THAN 100 VALUE
 LESS:
 POP ACC
 CJNE A,#100,LESS0 ; SEE IF (A) THREE DIGITS OR TWO
 LARG:
 MOV B,#100
 DIV AB
 MOV MULT_INTERMIDEATE,A ; HIGHEST ORDER VALUE
 MOV A,B
 SJMP LESS1
 LESS0: JNC LARG
 LESS1:MOV B,#10 ; (A) HAS TWO DIGIT
 DIV AB ; A=1 B=8
 MOV FIRST_RESULT,A ; INCASE OF A BUILD UP
 MOV SECOND_RESULT,B ; INCASE OF A BUILD UP
 ;--------------------------------------------------------------------------------------
 16
 JB FIRST_SECOND_SIGN,SINGLE_OP2 ; INCASE OF A DOUBLE OPERATION
 SETB FIRST_SECOND_SIGN ; TO PREVENT ENTERING HERE AGAIN
 MOV A,41H ; SECOND SIGN
 MOV 42H,A ; PUT SECOND SIGN IN FIRST SIGN PLACE (SWAP)
 ACALL COMBINING ; COMPINE THE FIRST&SECOND RESULT TOGEATHER
 ; TO MAKE A SINGLE REAL VALUE
 SETB REAL ; A HOLDS A REAL (NON-ASCII) VALUE
 MOV 60H,A ; COMBIEND REAL VALUE INTO 60H TO ACT AS A FIRST VALUE
 MOV A,62H ; THIRD DATA
 MOV 61H,A ; THIRD DATA INTO 61H TO ACT AS A SECOND VALUE
 LJMP SUCESSFUL
 ;----------------------------------------------------------------------------------------
 SINGLE_OP2:
 MOV A,ADDED_VALUE ; INCASE THERE WAS A FLOATING VALUE THAT
 ; BECAME A RESULT.REMINDER (2*0.75=1.5)
 JZ NO_ADDED ; CHECK IF THERE IS ADDED VALUE
 MOV B,SECOND_RESULT ;799 9+1=10 730
 ADD A,B ; A = ADDED_VALUE+SECOND_RESULT
 CJNE A,#10,N_NEW_VALUE ; INCASE A HAS A VALUE LARGER THAN 10
 ; WE INCREMENT THE FIRST_RESULT ASWELL
 NEW_VALUE:MOV B,#10
 DIV AB ; A=1 B=0
 MOV SECOND_RESULT,B
 MOV B,FIRST_RESULT
 ADD A,B
 MOV FIRST_RESULT,A
 N_NEW_VALUE: JNC NEW_VALUE
 MOV SECOND_RESULT,A
 NO_ADDED:
 MOV A,MULT_INTERMIDEATE ; THE HIGHEST VALUE EX: 729 --> 7
 JZ NEX_HIGH
 ORL A,#30H;FIRST
 ACALL DATAA
MOV MULT_INTERMIDEATE,#0 ; TO PREVENT ANY PREVIOUS VALUES TO ALTER THE FLOW
 MOV A,FIRST_RESULT ; EX 729 --> 2
 ORL A,#30H
 ACALL DATAA
 MOV A,SECOND_RESULT ; EX 729 --> 9
 ORL A,#30H
 ACALL DATAA
 17
 ACALL FLOAT_SHW
 RET
 NEX_HIGH:
 MOV A,FIRST_RESULT
 JZ SKIP10
 ORL A,#30H
 ACALL DATAA
 SKIP10: MOV A,SECOND_RESULT
 ORL A,#30H
 ACALL DATAA
 RET
 ;-------------------------------------------------------------
 ADDD:
 MOV A,60H ; REAL OR ASCII
 MOV B,61H
 JB REAL,REL0
 ANL A,#0FH
 REL0:
 ANL B,#0FH
 ADD A,B ;18+9 = 27
 MOV B,#10
 DIV AB ; A=2 B=7
 MOV FIRST_RESULT,A
 MOV SECOND_RESULT,B
 ORL A,#30H ; 32
 MOV 43H,A ;FIRST
 ORL B,#30H ; 37
 MOV 44H,B ;SECOND
 ;------------------------------------------------------------
 JB FIRST_SECOND_SIGN,SINGLE_OP
SETB FIRST_SECOND_SIGN
 MOV A,41H ; SECOND SIGN
 MOV 42H,A ; PUT SECOND SIGN IN FIRST SIGN PLACE
 ACALL COMBINING
 SETB REAL ; A HOLDS A NON-ASCII VALUE
 MOV 60H,A ; REAL VALUE INTO 60H TO ACT AS A FIRST VALUE
 MOV A,62H ; THIRD DATA
 MOV 61H,A ; THIRD DATA INTO 61H TO ACT AD A SECOND VALUE
 LJMP SUCESSFUL
 ;--------------------------------------------------------------
 18
 SINGLE_OP:
CJNE A,#30H,SKIP2
 SJMP SKIP3
 SKIP2:ACALL DATAA
 SKIP3: MOV A,44H
 ACALL DATAA
 RET
 ;-------------------------------------------------------------------
 SUB:
 CLR C
 MOV A,60H ;18
 MOV B,61H ;35
 JB REAL,REL00 ; SKIP MASK IF A HAS A NON-ASCII VALUE
 ANL A,#0FH
 REL00:
 ANL B,#0FH
 SUBB A,B
 JNC HH ; NEGATIVE VALUE
 SETB SUUB
 CPL A
 ADD A,#1
 PUSH ACC
 MOV A,#'-'
 ACALL DATAA
 POP ACC
 HH:
 MOV SECOND_RESULT,A
 MOV FIRST_RESULT,#0
 ;-------------------------------------------------------------------
 JB FIRST_SECOND_SIGN,SINGLE_OP1
 SETB FIRST_SECOND_SIGN
 MOV A,41H ; SECOND SIGN
 MOV 42H,A ; PUT SECOND SIGN IN FIRST SIGN PLACE
 ACALL COMBINING
 SETB REAL ; A HOLDS A NON-ASCII VALUE
 MOV 60H,A ; REAL VALUE INTO 60H TO ACT AS A FIRST VALUE
 MOV A,62H ; THIRD DATA
 MOV 61H,A ; THIRD DATA INTO 61H TO ACT AS A SECOND VALUE
 LJMP SUCESSFUL
 ;----------------------------------------------------------------------
 19
 SINGLE_OP1:
 ORL A,#30H
 ACALL DATAA
 RET
 ;---------------------------------------------------------------------
 DIVV:
 MOV R2,#2 ; NUMBER OF DIGITS AFTER '.'
 MOV B,61H ;
 ANL B,#0FH
 MOV A,B
 CJNE A,#0,CONT0 ; CHECK IF WE ARE DIVIDING BY ZERO
 ACALL ERR
 LJMP NEXT5
 CONT0:
 JNB DIIV,FLOAT_RESULT
 ACALL DIV_FLOAT
 CLR DIIV
 MOV B,61H
 FLOAT_RESULT:
 MOV A,60H
 JB REAL,REL1
 ANL A,#0FH
 REL1:
 DIV AB
 MOV FIRST_RESULT,A ; SAVE OPEARTION O/P
 MOV 43H,A ; VALUE
 MOV A,B ; A= 1
 CLR DIIV ; ASSUME THERE ISN'T A FLOAT VALUE
 JZ FIN7
 SETB DIIV ; INDICATION THAT A DIVISION HAS OCCURD AND THEIR IS A FLOATING VALUE
 MOV SECOND_FLOAT,#0 ; FORCE SECOND FLOAT TO BE ZERO INTIALLY
 TU: MOV A,B ; A=1
 JZ FIN7
 MOV A,B
 MOV B,#10
 MUL AB ;10
 MOV B,61H ;
 ANL B,#0FH
 DIV AB ; A=5
 JB FIRST_SECOND_FLOAT,SECOND_FLOAT_UPDATE ; IF =0, FIRST FLOAT WILL BE STORED
 20
 ; IF =1, SECOND FLOAT WILL BE STORED,
 ; FIRST FLOAT ALREADY STORED
 MOV FIRST_FLOAT,A ;7
 SETB FIRST_SECOND_FLOAT
 SJMP FIRST_F
 SECOND_FLOAT_UPDATE:
 MOV SECOND_FLOAT,A ; 5
 FIRST_F:
 DJNZ R2,TU
 FIN7:
 JB FIRST_SECOND_SIGN,SINGLE_OP3
 SETB FIRST_SECOND_SIGN
 MOV A,41H ; SECOND SIGN
 MOV 42H,A ; PUT SECOND SIGN IN FIRST SIGN PLACE
 JNB DIIV,NO_FLOAT
 ACALL FLOAT_COMB
 NO_FLOAT:
 MOV A,FIRST_RESULT ; ALREADY HAS A COMPIEND REAL VALUE
 SETB REAL ; A HOLDS A NON-ASCII VALUE
 MOV 60H,A ; REAL VALUE INTO 60H TO ACT AS A FIRST VALUE
 MOV A,62H ; THIRD DATA
 MOV 61H,A ; THIRD DATA INTO 61H TO ACT AS A SECOND VALUE
 LJMP SUCESSFUL
 SINGLE_OP3:
 MOV A,FIRST_RESULT
 ORL A,#30H
 ACALL DATAA
 ACALL FLOAT_SHW
 RET
 ;--------------------------------------------------
 MUL_FLOAT:
 MOV B,61H ; 2
 MOV A,COMP_FLOAT
 MUL AB ; 75 =150
 CJNE A,#100,ADD_VALUE
 ADD_VALUE0:MOV B,#100
 DIV AB ; A=1 , B=50
 MOV ADDED_VALUE,A
 MOV A,B
 21
 SEPERAT:
 MOV B,#10
 DIV AB ;A=5 B=0
 MOV FIRST_FLOAT,A
 MOV SECOND_FLOAT,B
 RET
 ADD_VALUE: JNC ADD_VALUE0
 SJMP SEPERAT
 DIV_FLOAT:
 MOV B,61H
 MOV A,COMP_FLOAT
 DIV AB ;A HAS THE REMIDER VALUE , READY TO SHW
 MOV B,#10
 DIV AB ; A=0 B=4
 MOV FIRST_FLOAT,A ; REAL VALUES, NON-ASCII
 MOV SECOND_FLOAT,B ; REAL VALUES, NON-ASCII
 RET
 ;-------------------------------------------------------------
 FLOAT_SHW:
 MOV A,FIRST_FLOAT
 JZ NEX_FLOAT
 MOV A,#'.'
 ACALL DATAA
 MOV A,FIRST_FLOAT
 ORL A,#30H
 ACALL DATAA
 MOV A,SECOND_FLOAT
 ORL A,#30H
 ACALL DATAA
 RET
 ;----------------------------------------------------------------
 NEX_FLOAT:MOV A,SECOND_FLOAT
 JZ NO_FLO
 MOV A,#'.'
 ACALL DATAA
 MOV A,FIRST_FLOAT
 ORL A,#30H
 ACALL DATAA
 NO_FLO:
 RET
 22
 ;-------------------------------------------------------------------
 ERR:
 MOV A,#0C0H ; FORCE CURSOR TO BEGIN TO 2ND LINE
 ACALL COM
 MOV DPTR,#ERROR
 B1:CLR A
 MOVC A,@A+DPTR
 CJNE A,#0,FIN; A NOT = 0 THEN A='SYN ERR'
 MOV R6,#4
 SETB NEW_OPERATION
 MOV R0,#60H
 RET
 FIN: ACALL DATAA
 INC DPTR
 SJMP B1
 ;-----------------------------------------------------------------------
 COM: MOV P1,A
 CLR P0.1
 SETB P0.0
 CLR P0.0
 ACALL DELAY
 RET
 ;-----------------------------------------------------------------------
 DATAA:
 MOV P1,A ; OUTPUT PORT TO LCD
 SETB P0.1 ;RS=1,DISPLAY DATA
 SETB P0.0 ;E=1
 CLR P0.0 ;E=0, HIGH TO LOW PULSE
 ACALL DELAY
 RET
 ;------------------------------------------------------------------------
 DELAY:
 MOV R3,#50
 H1:MOV R4,#255
 H: DJNZ R4,H
 DJNZ R3,H1
 RET
 ;--------------------------------------------------------------------------
 INTIALIZER:
 MOV A,#38H
 23
 ACALL COM
 MOV A,#0EH
 ACALL COM
 MOV A,#01H
 ACALL COM
 RET
 ;------------------------------------------------------------------------
 RESET_FLAGS:
 CLR REAL
 CLR DIIV
 MOV ERROR_FLAG,#0
 SETB NEW_OPERATION
 MOV R0,#60H
 CLR OPERATION_SIGN
 CLR DATA_OPERATION
 CLR FIRST_SECOND_DIGIT
 RET
 ANS_FEATURE:
 SETB ANS_F
 SETB REAL ; 60H ADDRESS WILL HAVE A NON-ASCII VALUE
 SETB CONT
 SETB FIRST_SECOND_SIGN
 MOV R7,A ;SIGN
 ACALL COMBINING;
 MOV B,A
 MOV A,#'A'
 ACALL DATAA
 MOV A,#'N'
 ACALL DATAA
 MOV A,#'S'
 ACALL DATAA
 MOV 42H,R7 ; SAVE SIGN IN MEMORY
 MOV A,R7
 ACALL DATAA
 MOV A,B ; RETURN REAL VALUE IN A TO STORE IT IN 60H
 RET
 FLOAT_COMB:
 MOV A,FIRST_FLOAT ;5
 MOV B,#10
 MUL AB ;50
 24
 MOV B,SECOND_FLOAT
 ADD A,B ;50
 MOV COMP_FLOAT,A ; A , COMP_FLOAT BOTH HAVE THE SAME FINAL VALUE
 RET
 ;--------------------------------------------------------------
 COMBINING:
 MOV A,FIRST_RESULT
 JZ LOP0
 MOV B,#10
 MUL AB
 MOV B,SECOND_RESULT
 ADD A,B ; A HAS FINAL REAL VALUE
 RET
 LOP0:
 MOV A,SECOND_RESULT ;REAL FINAL VALUE
 RET
 ;--------------------------------------------------------------
 KEY0: DB '1','2','3','+'
 KEY1: DB '4','5','6','-'
 KEY2: DB '7','8','9','*'
 KEY3: DB 'C','0','=','/'
 ERROR: DB "Syntax Error",0

 END
